\chapter{議論}
\label{chap:discussion}

\section{ストレージ消費量の推定}
一定の時間間隔$T$でスナップショットを取得するとして，
スナップショットの取得とFugaによるデータ保護の間で，$T$の間のストレージの消費量を比較する．
スナップショットを取得する対象領域に存在する全データの総量を$N$バイトとすると，
スナップショットによるストレージの消費量は
\begin{equation}
  \label{eq:snapshot-storage}
  N
\end{equation}
である．
一方，Fugaによるデータ退避は，誤検知による正常なデータ更新とランサムウェアによるデータ侵害の両方を対象とする．
\begin{itemize}
  \item Fugaが利用する検知手法の誤検知率を$fpr \;(0 \le fpr < 1)$
  \item $T$あたりに発生するデータ更新の量を$D$バイト
  \item ランサムウェアが侵害するデータの割合を$c \; (0 < c \le 1)$
\end{itemize}
% ，$T$あたりに発生するデータ更新の量を$D$バイト，
% ランサムウェアが侵害するデータの割合を$c \; (0 < c \le 1)$とすると，
と定義すると，
Fugaによるストレージの消費量は
\begin{equation}
  \label{eq:fuga-storage}
  fpr \times D + c \times N
\end{equation}
である．
Fugaがスナップショットよりもストレージを節約できる条件は，\eqref{eq:snapshot-storage}と\eqref{eq:fuga-storage}を比較して
\begin{equation}
  % \label{eq:storage-compare}
  fpr \times D + c \times N < N
\end{equation}
すなわち
\begin{equation}
  \label{eq:storage-compare}
  \frac{D}{N} < \frac{1-c}{fpr}
\end{equation}
である．
ここで，スナップショット対象領域内のデータ更新量$D$は，その領域の総データ量$N$と正の相関があると仮定する．
これは，対象領域が大きくなるほど，領域内で更新されるデータ量も増加する傾向があるためである．
この仮定に基づけば，更新量の比率$\frac{D}{N}$を用いて議論を行うことが妥当である．
よって，ストレージ消費量削減の観点から，$\frac{1-c}{fpr}$の値を評価することが次の検討対象となる．


2013年から2019年までのランサムウェア検知手法を対象とした調査\cite{berrueta2019survey} によると，
検知手法の誤検知率は \(10^{-4}\) から 0.1 の範囲にある.
実験環境ではなく実運用環境においては誤検知率の増加が予想されることと，Fuga は保守的な検知を行うことから，\(fpr = 0.2\) と仮定する．
このとき，\(c\) の値を複数変化させると
\begin{equation}
  \frac{1-c}{fpr} =
  \begin{cases}
    4.5 & (c = 0.1) \\
    2.5 & (c = 0.5) \\
    0   & (c = 1)
  \end{cases}
\end{equation}
となる．
この結果は，ランサムウェアによる侵害が部分的なデータに留まる場合 (\(c << 1\))，
Fuga がスナップショットよりも効率的にストレージを利用できることを示す．
特に~\ref{subsec:ransom-behavior} 節で述べたように，現実のランサムウェア攻撃では，必ずしも全てのデータが侵害される (\(c = 1\)) わけではなく，
一部のデータのみが標的となるケースも確認されている．
このようなケースでは，Fuga がスナップショットよりもストレージを節約できる可能性が高い．
また，\(c = 1\) となるケースでは，Fuga はスナップショットよりも多くのストレージを消費するが，
その場合スナップショットでは正常なデータ更新が完全に失われることに留意する必要がある．





\section{ランサムウェアの多様性への対応}
\ref{subsec:ransom-behavior}節で述べたように，ランサムウェアは暗号化を中心に様々な形態で被害を引き起こす．
ランサムウェアがファイルを侵害する方法は\ref{subsec:ransom-behavior}節の内容を踏まえて以下の3つに分類することができる．
\begin{enumerate}
  \item システムが標準的に提供する暗号化機能を利用する
  \item 独自の暗号化実装を使用する
  \item 暗号化を行わず，ファイルの上書きや削除を行う \footnote{厳密には暗号化ランサムウェアではないが，便宜上含める．}
\end{enumerate}
\ref{chap:design}章および\ref{chap:implementation}章ではFugaが（1）のタイプのランサムウェアに対してデータ保護を実現する方法を論じたが，本節では
（2）および（3）のタイプのランサムウェアに対してもFugaを適用するための設計を検討する．

\subsubsection{独自の暗号化処理を実装するタイプ}
ランサムウェアのサンプルが入手できるという前提をおく．
サンプルを動的解析することで暗号化関数を特定し，
前節と同様にCapturerを設計する．
なお，独自の暗号化処理を実装するランサムウェアは，\ref{subsec:encrypt-algo}節で述べたように近年稀である．


\subsubsection{暗号化以外の侵害を行うタイプ}
% 暗号化を解除する対価として身代金は要求するが，ファイルを暗号化しているように見せかけて実際にはランダムなデータで上書きするようなケースを考える．
このケースではCapturerは役割を持たず，Collectorが収集するファイルメタデータのみによってファイルを退避させる必要がある．
一例として．Collectorが取得したファイルパスをEvacuation Moduleに送信し，
Evacuation Moduleが該当ファイルをData Shelterにコピーする設計が考えられる．
しかしこの設計では，Data Shelterへの書き込みの負荷が非常に高くなることが懸念される．


\section{Fugaのカバレッジ分析}
Fugaは，ファイル以外を侵害するランサムウェアには対応できない．
例としてはOSを含むディスク全体を暗号化するMamba \cite{mamba-petya} や，Windowsシステムのマスターブートレコードとファイルシステムを暗号化するPetya \cite{mamba-petya} などが挙げられる．
このタイプのランサムウェアには，ファイルシステムまたはOSイメージのスナップショットの取得による対策が必要である．

Fugaはファイルの侵害からの復旧を実現するシステムであり，二重脅迫やノーウェアランサム \cite{nowhere-ransom} におけるデータ窃取はFugaのスコープ外である．
しかしランサムウェアのインシデントにおいてデータ窃取が行われる割合は増加傾向にある \cite{sophos-report:online}．
したがって，NDRなどの技術を活用したデータ窃取対策を検討する必要がある．

評価の結果が示すように，侵害されるファイルのサイズが大きくなると，Fugaはファイルを完全には保護できないという問題がある．
しかし一般的なエンドユーザ向けコンピュータ上のファイルのサイズ分布 \cite{file-size-dist} によると，32KB以下のファイルが全ファイル数の60\%以上を占め，
100MB以上のファイルは全ファイル数の1\%未満しか存在しない．
よって，Fugaによって保護できないような大容量のファイルが存在する場合でも，
それによる被害はシステム全体で見れば限定的であると考えられる．


\section{既存手法とFugaの比較}
\ref{sec:ransomware-recovery}節で説明したランサムウェア被害からの復旧手法をFugaと比較する．
\subsection{スナップショットを利用した復旧}
Fugaは\textbf{高頻度の}スナップショット取得によるデータ復旧の課題を解決する手法であり，
スナップショットを利用したデータバックアップを完全に置換するものではない．
むしろ，スナップショットとFugaは補完的に組み合わせることができる．
動画などのサイズが大きいファイルはスナップショットによるバックアップを用いて保護し，
サイズが小さく頻繁に更新されるファイルはFugaによってデータ更新を捕捉することで
効果的なデータ保護が期待できる．

\subsection{暗号化鍵の取得による復旧}
PayBreak \cite{kolodenker2017paybreak}は，ランサムウェアがデータの暗号化に使用する暗号化パラメータをキャプチャし，後に復号に使用する手法である．
この手法は暗号化されたデータのサイズに依存せず復旧を実現できる点で，Fugaよりも優れている側面がある．
しかし，PayBreakは原理的に共通鍵暗号方式を採用するランサムウェアに対してのみ有効である．
一方Fugaは，暗号化方式に依存せず平文データ自体を保護するため，より汎用性が高いといえる．
また，ランサムノートを提示した後に一定時間ごとに暗号化済みファイルを削除することで身代金の支払いを促すランサムウェア (e.g. Jigsaw \cite{byrne2017jigsaw})
に対しては，Fugaの方がデータ損失のリスクを効果的に抑えられる．

\subsection{SSDの特性を利用した復旧}
このタイプの手法 \cite{huang2017flashguard,baek2018ssd} にはいくつかの課題が指摘されている \cite{wang2024ransom}．
まず，SSDのファームウェアを拡張する必要があるため，ランサムウェアの急速な進化に対応するためにはファームウェアの頻繁な更新が求められる．
さらに，これらの手法は特殊なハードウェアまたは実験的なハードウェアに依存しており大規模な展開が困難である．
一方で，Fugaはソフトウェアを用いたアプローチであるため，新種のランサムウェアへの対応やシステムへの導入は比較的容易であるといえる．

\subsection{ファイルシステムの拡張による復旧}
ShiledFS \cite{shieldFS} のようにローカルファイルシステムにデータ復旧機能を追加する手法は，
正常なアプリケーションによる暗号化の誤検知や攻撃者による検知回避といった課題への対応が不十分であると指摘されている \cite{han2020effectiveness,css2024-enomoto}．
そのため，誤検知による誤った復旧や攻撃見逃しによるデータ損失のリスクが懸念される．
これに対し，Fugaは保守的な検知によって見逃しを削減することでデータ損失のリスクを軽減する．
また，誤検知が発生した場合でも無駄なバックアップが作成されるだけでデータ損失は発生しない．
なお，ローカルファイルシステムのクラウドバックアップを保護する手法 \cite{matos2018rockfs} は，Fugaとは
保護する対象が異なるアプローチであるため，本稿では比較を行わない．
