\chapter{Fugaの実装}
\ref{chap:design}章で述べたFugaの設計をもとにFugaを実装した．
本稿の実装は，TMP節で述べたケースの実例として，OpenSSLを利用して暗号化を行うランサムウェアを対象としている．
カーネル空間のプログラムはeBPF \cite{WhatiseB81:online} を利用して，
ユーザ空間のプログラムはGo言語を用いて実装した．
．本稿の執筆時点においてeBPFは実用上Linux環境のみで利用可能であるため，
Linux環境にて実装を行った．
実装に使用したシステムの環境を\tabref{tab:impl-env}に示す．
\begin{table}[tb]
  \caption{Implementation environment for Fuga.}
  \label{tab:impl-env}
  \hbox to\hsize{\hfil
    \begin{tabular}{l|lll}
      \hline
      Linuxカーネル  & 6.3.0-060300-generic \\
      CPUアーキテクチャ & amd64                \\
      clang      & 14.0.0-1ubuntu1.1    \\
      Goコンパイラ    & go1.22.5 linux/amd64 \\
    \end{tabular}\hfil}
\end{table}

\section{各コンポーネントの実装}
本節ではFugaの実装特有の詳細を説明する．
Detectorの実装は本研究のスコープ外であることに注意する．

\subsection{Process Monitor}
Capturerは，OpenSSL内の暗号化関数をuprobeでフックするeBPFプログラムとして実装した．
暗号化関数には引数として平文データが格納されているバッファへのポインタが渡されるため，
eBPFプログラム内でこのポインタをキャプチャしユーザ空間からカーネル空間へ平文データをコピーする．
コピーされた平文データは，関連するメタデータとともに暗号化イベントを表す構造体に格納され，
eBPF mapのリングバッファを介してEvacuation Moduleに送信される．
なお，本稿で示す実装においてはOpenSSLの暗号化関数のみを対象としているが，
OpenSSL以外の暗号化ライブラリにも容易に同じ手法を適用することができる．

CollectorはCapturerが取得した平文データに対して，
元ファイルの絶対パスと元ファイル上のオフセットを取得する機能を持つ．
上述したようにCollectorがアクセスできるのは平文データのポインタのみであり，ポインタから絶対パスやオフセットを直接取得することはできない．
そこで本研究では，FD (File Descriptor) を仲介して必要なデータを取得する方法を採用した．
元ファイルのポインタからFDの値を特定することができれば，
\texttt{open(2)}システムコールのフックから相対または絶対パスを，
\texttt{lseek(2)}および\textt{read(2)}システムコールのフックからオフセットを取得することができる．


それぞれの機能を以下のように実装した．
\\
\textbf{元ファイルの絶対パスの特定}:
